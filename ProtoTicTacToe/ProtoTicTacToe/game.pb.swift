// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: game.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Symbol: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case circle // = 0
  case cross // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .circle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .circle
    case 1: self = .cross
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .circle: return 0
    case .cross: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Symbol: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Symbol] = [
    .circle,
    .cross,
  ]
}

#endif  // swift(>=4.2)

struct GameSearchHandshake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clientUuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GameFoundHandshake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gameUuid: String = String()

  var assignedSymbol: Symbol = .circle

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Move {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gameUuid: String = String()

  var position: Position {
    get {return _position ?? Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var clientUuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Position? = nil
}

struct Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var row: Int32 = 0

  var column: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GameState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var board: Board {
    get {return _board ?? Board()}
    set {_board = newValue}
  }
  /// Returns true if `board` has been explicitly set.
  var hasBoard: Bool {return self._board != nil}
  /// Clears the value of `board`. Subsequent reads from it will return its default value.
  mutating func clearBoard() {self._board = nil}

  var isYourTurn: Bool = false

  var timeLimit: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeLimit ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeLimit = newValue}
  }
  /// Returns true if `timeLimit` has been explicitly set.
  var hasTimeLimit: Bool {return self._timeLimit != nil}
  /// Clears the value of `timeLimit`. Subsequent reads from it will return its default value.
  mutating func clearTimeLimit() {self._timeLimit = nil}

  var winState: GameState.WinState {
    get {return _winState ?? GameState.WinState()}
    set {_winState = newValue}
  }
  /// Returns true if `winState` has been explicitly set.
  var hasWinState: Bool {return self._winState != nil}
  /// Clears the value of `winState`. Subsequent reads from it will return its default value.
  mutating func clearWinState() {self._winState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct WinState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var winStateEnum: GameState.WinState.OneOf_WinStateEnum? = nil

    var nobody: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .nobody(let v)? = winStateEnum {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {winStateEnum = .nobody(newValue)}
    }

    var winner: GameState.WinState.WinningLine {
      get {
        if case .winner(let v)? = winStateEnum {return v}
        return GameState.WinState.WinningLine()
      }
      set {winStateEnum = .winner(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_WinStateEnum: Equatable {
      case nobody(SwiftProtobuf.Google_Protobuf_Empty)
      case winner(GameState.WinState.WinningLine)

    #if !swift(>=4.1)
      static func ==(lhs: GameState.WinState.OneOf_WinStateEnum, rhs: GameState.WinState.OneOf_WinStateEnum) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.nobody, .nobody): return {
          guard case .nobody(let l) = lhs, case .nobody(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.winner, .winner): return {
          guard case .winner(let l) = lhs, case .winner(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    struct WinningLine {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var positions: [Position] = []

      var symbol: Symbol = .circle

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _board: Board? = nil
  fileprivate var _timeLimit: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _winState: GameState.WinState? = nil
}

struct Board {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// For 3x3 this should always have 9 elements.
  var boxStates: [Board.BoxState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct BoxState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var boxStateEnum: Board.BoxState.OneOf_BoxStateEnum? = nil

    var empty: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .empty(let v)? = boxStateEnum {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {boxStateEnum = .empty(newValue)}
    }

    var symbol: Symbol {
      get {
        if case .symbol(let v)? = boxStateEnum {return v}
        return .circle
      }
      set {boxStateEnum = .symbol(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_BoxStateEnum: Equatable {
      case empty(SwiftProtobuf.Google_Protobuf_Empty)
      case symbol(Symbol)

    #if !swift(>=4.1)
      static func ==(lhs: Board.BoxState.OneOf_BoxStateEnum, rhs: Board.BoxState.OneOf_BoxStateEnum) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.empty, .empty): return {
          guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.symbol, .symbol): return {
          guard case .symbol(let l) = lhs, case .symbol(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Symbol: @unchecked Sendable {}
extension GameSearchHandshake: @unchecked Sendable {}
extension GameFoundHandshake: @unchecked Sendable {}
extension Move: @unchecked Sendable {}
extension Position: @unchecked Sendable {}
extension GameState: @unchecked Sendable {}
extension GameState.WinState: @unchecked Sendable {}
extension GameState.WinState.OneOf_WinStateEnum: @unchecked Sendable {}
extension GameState.WinState.WinningLine: @unchecked Sendable {}
extension Board: @unchecked Sendable {}
extension Board.BoxState: @unchecked Sendable {}
extension Board.BoxState.OneOf_BoxStateEnum: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Symbol: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CIRCLE"),
    1: .same(proto: "CROSS"),
  ]
}

extension GameSearchHandshake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GameSearchHandshake"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientUuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.clientUuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GameSearchHandshake, rhs: GameSearchHandshake) -> Bool {
    if lhs.clientUuid != rhs.clientUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GameFoundHandshake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GameFoundHandshake"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameUuid"),
    2: .same(proto: "assignedSymbol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gameUuid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.assignedSymbol) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.gameUuid, fieldNumber: 1)
    }
    if self.assignedSymbol != .circle {
      try visitor.visitSingularEnumField(value: self.assignedSymbol, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GameFoundHandshake, rhs: GameFoundHandshake) -> Bool {
    if lhs.gameUuid != rhs.gameUuid {return false}
    if lhs.assignedSymbol != rhs.assignedSymbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Move"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameUuid"),
    2: .same(proto: "position"),
    3: .same(proto: "clientUuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gameUuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.gameUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.gameUuid, fieldNumber: 1)
    }
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.clientUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.clientUuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Move, rhs: Move) -> Bool {
    if lhs.gameUuid != rhs.gameUuid {return false}
    if lhs._position != rhs._position {return false}
    if lhs.clientUuid != rhs.clientUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "row"),
    2: .same(proto: "column"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.row) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.column) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.row != 0 {
      try visitor.visitSingularInt32Field(value: self.row, fieldNumber: 1)
    }
    if self.column != 0 {
      try visitor.visitSingularInt32Field(value: self.column, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Position, rhs: Position) -> Bool {
    if lhs.row != rhs.row {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GameState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GameState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "board"),
    2: .same(proto: "isYourTurn"),
    3: .same(proto: "timeLimit"),
    4: .same(proto: "winState"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._board) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isYourTurn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeLimit) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._winState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._board {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isYourTurn != false {
      try visitor.visitSingularBoolField(value: self.isYourTurn, fieldNumber: 2)
    }
    try { if let v = self._timeLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._winState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GameState, rhs: GameState) -> Bool {
    if lhs._board != rhs._board {return false}
    if lhs.isYourTurn != rhs.isYourTurn {return false}
    if lhs._timeLimit != rhs._timeLimit {return false}
    if lhs._winState != rhs._winState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GameState.WinState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GameState.protoMessageName + ".WinState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nobody"),
    2: .same(proto: "winner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.winStateEnum {
          hadOneofValue = true
          if case .nobody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.winStateEnum = .nobody(v)
        }
      }()
      case 2: try {
        var v: GameState.WinState.WinningLine?
        var hadOneofValue = false
        if let current = self.winStateEnum {
          hadOneofValue = true
          if case .winner(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.winStateEnum = .winner(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.winStateEnum {
    case .nobody?: try {
      guard case .nobody(let v)? = self.winStateEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .winner?: try {
      guard case .winner(let v)? = self.winStateEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GameState.WinState, rhs: GameState.WinState) -> Bool {
    if lhs.winStateEnum != rhs.winStateEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GameState.WinState.WinningLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GameState.WinState.protoMessageName + ".WinningLine"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "positions"),
    2: .same(proto: "symbol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.positions) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.symbol) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.positions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positions, fieldNumber: 1)
    }
    if self.symbol != .circle {
      try visitor.visitSingularEnumField(value: self.symbol, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GameState.WinState.WinningLine, rhs: GameState.WinState.WinningLine) -> Bool {
    if lhs.positions != rhs.positions {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Board: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Board"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "boxStates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.boxStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.boxStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.boxStates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Board, rhs: Board) -> Bool {
    if lhs.boxStates != rhs.boxStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Board.BoxState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Board.protoMessageName + ".BoxState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "empty"),
    2: .same(proto: "symbol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.boxStateEnum {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.boxStateEnum = .empty(v)
        }
      }()
      case 2: try {
        var v: Symbol?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.boxStateEnum != nil {try decoder.handleConflictingOneOf()}
          self.boxStateEnum = .symbol(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.boxStateEnum {
    case .empty?: try {
      guard case .empty(let v)? = self.boxStateEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .symbol?: try {
      guard case .symbol(let v)? = self.boxStateEnum else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Board.BoxState, rhs: Board.BoxState) -> Bool {
    if lhs.boxStateEnum != rhs.boxStateEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
